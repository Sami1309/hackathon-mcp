#!/usr/bin/env python3
"""
Script to start a pentest on NodeZero MCP server and stream logs.
This script connects to the MCP server, starts a new pentest, and streams
real-time logs if available.
"""

import json
import subprocess
import sys
import time
import threading
from datetime import datetime
from pathlib import Path

class NodeZeroClient:
    def __init__(self):
        self.api_key = "MToxNmNkNGI5NS0zMmEzLTQ5MjgtYmQwOC1jZTUxMGQ1YzJiYmU6RzlEdmhGOTlFQ052RTgvdXVLbStZcWRETTdLd3cvbzM4NldubUQ1bFF2Ymk3LzY2"
        self.process = None
        self.request_id = 1

    def start_mcp_server(self):
        """Start the MCP server process."""
        try:
            self.process = subprocess.Popen([
                'docker', 'run', '--pull', 'always', '-i', '--rm',
                '-e', f'H3_API_KEY={self.api_key}',
                'horizon3ai/h3-mcp-server:latest'
            ], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            print("MCP Server started successfully")
            return True
        except Exception as e:
            print(f"Failed to start MCP server: {e}")
            return False

    def send_command(self, method, params=None):
        """Send a command to the MCP server."""
        if not self.process:
            print("MCP server not started")
            return None

        command = {
            "jsonrpc": "2.0",
            "id": self.request_id,
            "method": method,
            "params": params or {}
        }

        self.request_id += 1

        try:
            command_str = json.dumps(command) + "\n"
            self.process.stdin.write(command_str)
            self.process.stdin.flush()

            # Read response
            response = self.process.stdout.readline()
            if response:
                return json.loads(response.strip())
            return None

        except Exception as e:
            print(f"Error sending command: {e}")
            return None

    def get_available_tools(self):
        """Get list of available tools."""
        return self.send_command("tools/list")

    def start_pentest(self, target, scan_type="comprehensive"):
        """Start a new pentest."""
        params = {
            "name": "start_pentest",
            "arguments": {
                "target": target,
                "scan_type": scan_type
            }
        }
        return self.send_command("tools/call", params)

    def get_pentest_status(self, pentest_id):
        """Get status of a running pentest."""
        params = {
            "name": "get_pentest_status",
            "arguments": {
                "pentest_id": pentest_id
            }
        }
        return self.send_command("tools/call", params)

    def get_pentest_logs(self, pentest_id):
        """Get logs for a pentest."""
        params = {
            "name": "get_pentest_logs",
            "arguments": {
                "pentest_id": pentest_id
            }
        }
        return self.send_command("tools/call", params)

    def list_targets(self):
        """List available targets."""
        params = {
            "name": "list_targets",
            "arguments": {}
        }
        return self.send_command("tools/call", params)

    def close(self):
        """Close the MCP server connection."""
        if self.process:
            self.process.terminate()
            self.process.wait()

def stream_logs(client, pentest_id, log_file):
    """Stream logs for a pentest to console and file."""
    print(f"\nStreaming logs for pentest {pentest_id}...")
    print("=" * 50)

    last_log_count = 0

    while True:
        try:
            # Get current status
            status_response = client.get_pentest_status(pentest_id)
            if status_response and "result" in status_response:
                status = status_response["result"].get("status", "unknown")
                print(f"Status: {status} [{datetime.now().strftime('%H:%M:%S')}]")

                # If completed, break after getting final logs
                if status.lower() in ["completed", "finished", "done", "failed", "error"]:
                    print(f"Pentest {status.lower()}, getting final logs...")
                    break

            # Get logs
            logs_response = client.get_pentest_logs(pentest_id)
            if logs_response and "result" in logs_response:
                logs_data = logs_response["result"]

                if isinstance(logs_data, dict) and "logs" in logs_data:
                    logs = logs_data["logs"]
                elif isinstance(logs_data, list):
                    logs = logs_data
                else:
                    logs = [str(logs_data)]

                # Display new logs
                if len(logs) > last_log_count:
                    new_logs = logs[last_log_count:]
                    for log_entry in new_logs:
                        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        log_line = f"[{timestamp}] {log_entry}"
                        print(log_line)

                        # Write to file
                        with open(log_file, 'a') as f:
                            f.write(log_line + "\n")

                    last_log_count = len(logs)

            time.sleep(5)  # Wait 5 seconds before next check

        except KeyboardInterrupt:
            print("\nStopping log streaming...")
            break
        except Exception as e:
            print(f"Error streaming logs: {e}")
            time.sleep(5)

def main():
    """Main function to start pentest and stream logs."""
    print("NodeZero Pentest Starter & Log Streamer")
    print("=" * 45)

    client = NodeZeroClient()

    try:
        # Start MCP server
        if not client.start_mcp_server():
            return

        # Wait a moment for server to initialize
        time.sleep(2)

        # Get available tools
        print("Getting available tools...")
        tools_response = client.get_available_tools()
        if tools_response:
            print("Available tools retrieved successfully")
            if "result" in tools_response:
                tools = tools_response["result"]
                print(f"Found {len(tools.get('tools', []))} available tools")

        # List available targets first
        print("\nGetting available targets...")
        targets_response = client.list_targets()
        if targets_response and "result" in targets_response:
            targets = targets_response["result"]
            print(f"Available targets: {targets}")

            # Use first target or default
            if isinstance(targets, list) and targets:
                target = targets[0]
            else:
                target = "192.168.1.0/24"  # Default target
        else:
            target = "192.168.1.0/24"  # Default fallback

        print(f"\nStarting pentest against target: {target}")

        # Start pentest
        pentest_response = client.start_pentest(target)
        if not pentest_response:
            print("Failed to start pentest")
            return

        print(f"Pentest response: {json.dumps(pentest_response, indent=2)}")

        # Extract pentest ID
        pentest_id = None
        if "result" in pentest_response:
            result = pentest_response["result"]
            if isinstance(result, dict):
                pentest_id = result.get("pentest_id") or result.get("id") or result.get("job_id")
            elif isinstance(result, str):
                pentest_id = result

        if not pentest_id:
            print("Could not extract pentest ID from response")
            return

        print(f"Pentest started with ID: {pentest_id}")

        # Set up log file
        log_file = Path(f"pentest_logs_{pentest_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt")

        # Initialize log file
        with open(log_file, 'w') as f:
            f.write(f"Pentest Log Stream - ID: {pentest_id}\n")
            f.write(f"Started: {datetime.now().isoformat()}\n")
            f.write(f"Target: {target}\n")
            f.write("=" * 50 + "\n\n")

        print(f"Logs will be saved to: {log_file}")

        # Stream logs
        stream_logs(client, pentest_id, log_file)

    except KeyboardInterrupt:
        print("\nOperation interrupted by user")
    except Exception as e:
        print(f"Unexpected error: {e}")
    finally:
        client.close()
        print("MCP client closed")

if __name__ == "__main__":
    main()